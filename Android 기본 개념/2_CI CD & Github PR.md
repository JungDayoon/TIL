# CI/CD & Github PR

# CI/CD

## **전통적인 배포 파이프라인 단계**

```
1. Version Control: 일반적으로 코드를 가지고 일을 하는 소프트웨어 개발자들은 코드 변경사항을 커밋한다.
2. Acceptance Tests: 미리 컴파일/빌드된 코드에 대해 테스트 묶음을 실행한다.
3. Independence Deployment: 독립 배포는 컴파일되고 테스트된 아티팩트를 개발환경에 배포한다. 개발 환경은 이상적으로 프로덕트 환경과 아주 비슷해야 한다.
4. Production Deployment: 일반적으로 운영팀이나 데브옵스팀에 의해서 다뤄진다. 이것은 Independent Deployment 프로세스와 매우 유사해야하고, 프로덕션 서버에 코드를 배포한다.
5. 이러한 기존방식으로 Human Error가 발생할 수 있다. 지루하고 반복적인 작업을 수동으로 하게되면 에러가 발생할 수 있고, 결국 잘못된 배포로 이어진다.
```

- 소프트웨어가 거대해지고 복잡해지면서 분업과 협업은 필수가 되었다. → 코드의 Merge 과정은 까다롭고, 테스트하는 데에 큰 자원을 소비한다.
- 개발 브랜치가 일정기간 이상 이용되면, 통합의 어려움은 커지고 충돌 해결에 들어가는 시간이 길어지고 오류 발생 위험이 커진다. 이러한 단점을 극복하고자 변동 내용의 반영 빈도를 늘리는 자동화가 등장했다.
- 빌드와 기능성을 검증하는 새로운 방법을 확보하고 기능의 개발과 배치속도를 큰 폭으로 개선하기 시작했다.

## CI/CD 정의

CI/CD는 애플리케이션 개발 단계를 자동화 하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법이다.

CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포이다. 즉, 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(일명 "Integration Hell")을 해결하기 위한 솔루션이다.

## CI와 CD의 차이점

**CI**

- 개발자를 위한 자동화 프로세스인 **지속적인 통합(Countinous Integration)**을 의미한다.

    → ***코드에 대한 통합을 지속적으로 진행함으로써 품질을 유지하자***

- CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결 가능

**CD**

- **지속적인 서비스 제공(Continuous Delivery)** 및 **지속적인 배포(Continous Deployment)**를 의미한다.

    ***→ 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리하자***

- 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만, 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.
- 지속적인 제공이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드 되는 것을 뜻한다. 운영팀은 이 레포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다. 이는 개발팀과 비즈니스팀 간의 가시성, 커뮤니케이션 부족 문제를 해결해준다. 지속적인 제공은 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 한다.
- 지속적인 배포란 개발자의 변경 사항을 레포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리즈 하는 것을 의미한다. 이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결한다.

![Untitled](https://user-images.githubusercontent.com/45536712/126260708-0f310945-0bb9-426b-843b-ef0228847ef7.png)


## 정리

즉, CI 프로세스를 통해 개발중에 지속적으로 빌드와 테스트를 진행하고, 

이를 통과한 코드에 대하여 테스트 서버와 운영 서버에 곧바로 그 내용을 배포해서 반영하는 것이다.(CD)

이상적인 환경이라면, 테스트와 빌드가 지속적으로 이루어지기 때문에, 배포 또한 자연스럽게 지속적으로 이루어지게 된다.

→ CI/CD 구현 툴? CircleCI, Travis, Jenkins 등..

# Github Pull Requests

## Pull Requests 란?

"Commit 한 내용을 Master에 Merge 해도 될까요?"를 동료들에게 말해주는 활동

**사용 이유**

- 자연스러운 코드 리뷰를 위해
- Push 권한이 없는 오픈 소스 프로젝트에 기여할 때
- 콜라보레이터로 소속되어 있는 경우에는 그 저장소에서 브랜치를 따고 푸쉬하면 PR이 가능하다.
- push로 협업했을 때에는 다른 사람의 commit을 볼 일이 잘 없고, master branch와 merge할 때서야 보게 되는데, Pull Request는 당장 merge하지 않는다는 규칙이 있기 때문에 PR을 보고 코드에 신경 쓰게 되고 어떤 작업이 언제 적용 되었는 지 알 수 있다.

## Pull Request Test

![Untitled 1](https://user-images.githubusercontent.com/45536712/126260733-51283c06-8e90-4601-a4d9-ade5b95f6fb5.png)


1. 리모트 브랜치로 push 하기

    main → develop → feature/test 브랜치를 생성

    이 브랜치에서 test.txt 파일을 생성한 후 commit

    test commit은 feature/test 브랜치에서 진행했기 때문에 master 브랜치나 develop 브랜치는 첫번째 커밋했던 initial commit에 머문다.

2. develop 브랜치에 병합 후 push

    feature 브랜치에서 작업이 끝나면 develop 브랜치에 병합해야 한다. develop 브랜치에 각자 개발한 기능들이 합쳐지게 된다.

3. Pull Request (develop 브랜치에 병합할 때 PR을 하는 지?)

    작업한 내용들을 요약해서 정리 → 한 기능만 한 PR에 작성하는 것이 좋음

    나중에 어떤 문제가 발생 시 어느 PR에서 발생했는 지 찾기 쉽기 때문

4. Pull Request Review

    변경된 히스토리들을 보면서 코멘트 달기 가능

    Comment, Approve, Request Changes 중 하나를 선택 가능

5. Pull Request 병합
    - Rebase and merge
        - PR의 커밋 로그들이 main에 재정렬돼서 병합된다. PR에서 작성한 모든 커밋들이 main에서 관리되어야 한다면 Rebase and merge로 병합하는 것이 좋다. 로컬에서 작성된 모든 커밋 로그들까지 추적할 수 있는 장점이 있다.
    - Squash and merge
        - PR의 commit log들을 한 개로 추려서 main에 병합하는 방법.
6. PR 병합 후

    Revert를 통해서 PR의 모든 commit을 되돌릴 수 있다.

    PR 병합 후 해당 브랜치가 필요 없다면 지울 수 있다.

unit test, UI test, scenario test(서버 배포 오류까지 모두 찾을 수 있음)
